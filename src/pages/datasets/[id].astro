---
import Layout from '../../layouts/Layout.astro';
import Nav from '../../components/Nav.astro';
import Footer from '../../components/Footer.astro';
import datasets from '../../data/datasets.json';
import { buildBasePath, normalizeBasePath } from '../../utils/base-path';

const processedModules = import.meta.glob('../../data/processed/*.json', { eager: true });
const evidenceModules = import.meta.glob('../../data/evidence/*.evidence.json', { eager: true });

interface DatasetSummary {
  id: string;
  title: string;
  titleEn: string;
  description: string;
  icon: string;
  category: string;
  categoryEn: string;
  updatedAt: string;
  format: string;
  url: string;
  sourcePageUrl?: string;
  status?: 'available' | 'unavailable';
  rowCount?: number;
  columnCount?: number;
  fileSizeBytes?: number;
  fetchedAt?: string;
  license?: string;
  sha256?: string;
  error?: string;
}

interface ProcessedDataset {
  headers: string[];
  records: Record<string, string>[];
}

interface EvidenceDataset {
  source?: {
    url?: string;
    detail_page_url?: string;
    license?: string;
  };
  acquisition?: {
    timestamp?: string;
    method?: string;
  };
  integrity?: {
    sha256?: string;
  };
  transformation?: {
    description?: string;
  };
}

interface GeoPoint {
  lat: number;
  lon: number;
  label: string;
  sublabel: string;
}

interface Bounds {
  minLat: number;
  maxLat: number;
  minLon: number;
  maxLon: number;
}

interface RegionPopulation {
  name: string;
  total: number;
  male: number;
  female: number;
  households: number;
}

export function getStaticPaths() {
  return (datasets as DatasetSummary[]).map(dataset => ({
    params: { id: dataset.id },
    props: { dataset },
  }));
}

const { dataset } = Astro.props as { dataset: DatasetSummary };

const unwrapModule = <T,>(mod: unknown): T | null => {
  if (!mod) {
    return null;
  }

  if (typeof mod === 'object' && mod !== null && 'default' in mod) {
    return (mod as { default: T }).default;
  }

  return mod as T;
};

const processed = unwrapModule<ProcessedDataset>(
  processedModules[`../../data/processed/${dataset.id}.json`],
);

const evidence = unwrapModule<EvidenceDataset>(
  evidenceModules[`../../data/evidence/${dataset.id}.evidence.json`],
);

const records = processed?.records ?? [];
const previewRows = records.slice(0, 20);
const tableKeys = Object.keys(previewRows[0] ?? {});
const headerLabels =
  processed?.headers?.length === tableKeys.length ? processed.headers : tableKeys;

const toNumber = (value: unknown) => {
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : 0;
  }

  if (typeof value === 'string') {
    const normalized = value.replace(/,/g, '').trim();
    if (!normalized) {
      return 0;
    }
    const parsed = Number(normalized);
    return Number.isFinite(parsed) ? parsed : 0;
  }

  return 0;
};

const toCoordinate = (value: unknown, type: 'lat' | 'lon'): number | null => {
  if (typeof value !== 'string' && typeof value !== 'number') {
    return null;
  }

  const parsed = Number(String(value).replace(/,/g, '').trim());
  if (!Number.isFinite(parsed)) {
    return null;
  }

  if (type === 'lat') {
    return parsed >= -90 && parsed <= 90 ? parsed : null;
  }

  return parsed >= -180 && parsed <= 180 ? parsed : null;
};

const findHeader = (headers: string[], patterns: RegExp[]) =>
  headers.find(header => patterns.some(pattern => pattern.test(header)));

const fmtDateTime = (value?: string) => {
  if (!value) {
    return '未取得';
  }

  return new Date(value).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
};

const fmtBytes = (value?: number) => {
  if (typeof value !== 'number') {
    return '-';
  }

  if (value < 1024) {
    return `${value} B`;
  }

  if (value < 1024 ** 2) {
    return `${(value / 1024).toFixed(2)} KB`;
  }

  return `${(value / 1024 ** 2).toFixed(2)} MB`;
};

const fmtPercent = (numerator: number, denominator: number, digits = 1) => {
  if (denominator <= 0) {
    return '-';
  }

  return `${((numerator / denominator) * 100).toFixed(digits)}%`;
};

const fmtDecimal = (value: number | null, digits = 1) => {
  if (value === null || !Number.isFinite(value)) {
    return '-';
  }

  return value.toFixed(digits);
};

const basePath = normalizeBasePath(import.meta.env.BASE_URL);
const homeUrl = buildBasePath(basePath, '#datasets');
const localSnapshotUrl = buildBasePath(basePath, `data/raw/${dataset.id}.csv`);
const leafletJsUrl = buildBasePath(basePath, 'leaflet.js');
const leafletCssUrl = buildBasePath(basePath, 'leaflet.css');

const evidenceSourceUrl = evidence?.source?.url ?? dataset.url;
const evidencePageUrl = evidence?.source?.detail_page_url ?? dataset.sourcePageUrl;
const evidenceFetchedAt = evidence?.acquisition?.timestamp ?? dataset.fetchedAt;
const evidenceLicense = evidence?.source?.license ?? dataset.license ?? 'CC BY 2.1 JP';
const evidenceSha = evidence?.integrity?.sha256 ?? dataset.sha256 ?? '-';
const transformationText =
  evidence?.transformation?.description ?? 'CSV (Shift_JIS/UTF-8) → UTF-8 → JSON';

const latHeader = processed
  ? findHeader(processed.headers, [/^緯度$/i, /緯度/i, /^lat$/i, /latitude/i])
  : undefined;
const lonHeader = processed
  ? findHeader(processed.headers, [/^経度$/i, /経度/i, /^lon$/i, /^lng$/i, /longitude/i])
  : undefined;
const labelHeader = processed
  ? findHeader(processed.headers, [/^名称$/, /^介護サービス事業所名称$/, /^データ名称$/, /^地域名$/, /名称/, /地域名/])
  : undefined;
const sublabelHeader = processed
  ? findHeader(processed.headers, [/^所在地$/, /住所/, /位置/, /場所/, /連絡先住所/])
  : undefined;
const categoryHeader = processed
  ? findHeader(processed.headers, [/^種別$/, /分類/, /区分/, /カテゴリ/, /文化財分類/, /^地域名$/])
  : undefined;

const geoPoints: GeoPoint[] = [];
if (processed && latHeader && lonHeader) {
  for (const row of records) {
    const lat = toCoordinate(row[latHeader], 'lat');
    const lon = toCoordinate(row[lonHeader], 'lon');
    if (lat === null || lon === null) {
      continue;
    }

    geoPoints.push({
      lat,
      lon,
      label: (labelHeader ? row[labelHeader] : '').trim() || `地点 ${geoPoints.length + 1}`,
      sublabel: (sublabelHeader ? row[sublabelHeader] : '').trim(),
    });
  }
}

const NAMEGATA_CITY_BOUNDS: Bounds = {
  minLat: 35.9,
  maxLat: 36.2,
  minLon: 140.33,
  maxLon: 140.6,
};

const isInBounds = (point: GeoPoint, bounds: Bounds) =>
  point.lat >= bounds.minLat &&
  point.lat <= bounds.maxLat &&
  point.lon >= bounds.minLon &&
  point.lon <= bounds.maxLon;

const geoPointsInCity = geoPoints.filter(point => isInBounds(point, NAMEGATA_CITY_BOUNDS));
const excludedOutsideCityPoints = geoPoints.filter(point => !isInBounds(point, NAMEGATA_CITY_BOUNDS));
const excludedOutsideCityCount = Math.max(geoPoints.length - geoPointsInCity.length, 0);
const excludedPointPreviewLimit = 25;
const excludedPointPreview = excludedOutsideCityPoints.slice(0, excludedPointPreviewLimit);
const hiddenExcludedOutsideCityCount = Math.max(
  excludedOutsideCityPoints.length - excludedPointPreview.length,
  0,
);

const maxMapPoints = 300;
const mapPoints = geoPointsInCity.slice(0, maxMapPoints);
const hiddenGeoPointCount = Math.max(geoPointsInCity.length - mapPoints.length, 0);
const hasGeoMap = mapPoints.length > 0;
const hasOnlyOutsideCityGeoPoints = geoPoints.length > 0 && !hasGeoMap;
const mapElementId = `dataset-map-${dataset.id.replace(/[^a-z0-9-]/gi, '')}`;

const categoryCountMap = new Map<string, number>();
if (processed && categoryHeader) {
  for (const row of records) {
    const value = (row[categoryHeader] ?? '').trim();
    if (!value) {
      continue;
    }
    categoryCountMap.set(value, (categoryCountMap.get(value) ?? 0) + 1);
  }
}

const categoryDistribution = Array.from(categoryCountMap.entries())
  .map(([label, count]) => ({ label, count }))
  .sort((a, b) => b.count - a.count)
  .slice(0, 8);
const hiddenCategoryCount = Math.max(categoryCountMap.size - categoryDistribution.length, 0);
const maxCategoryCount = Math.max(...categoryDistribution.map(item => item.count), 0);
const hasCategoryChart = categoryDistribution.length > 1;

const isPopulationDataset = dataset.id === 'population' && !!processed;
const ageColumns: Array<{ label: string; key: string; sex: 'male' | 'female' }> = [];
const seenAgeLabels = new Set<string>();
const regionPopulationRows: RegionPopulation[] = [];
const surveyDateSet = new Set<string>();

if (isPopulationDataset) {
  for (const header of processed.headers) {
    const ageMatch = header.match(/^(.+?)の(男性|女性)(以上)?$/);
    if (!ageMatch) {
      continue;
    }

    const label = ageMatch[3] ? `${ageMatch[1]}以上` : ageMatch[1];
    const sex = ageMatch[2] === '男性' ? 'male' : 'female';
    ageColumns.push({ label, key: header, sex });
    seenAgeLabels.add(label);
  }
}

const ageDistribution = Array.from(seenAgeLabels).map(label => ({ label, total: 0 }));
const ageDistributionMap = new Map(ageDistribution.map(item => [item.label, item]));
const ageSexDistribution = Array.from(seenAgeLabels).map(label => ({ label, male: 0, female: 0, total: 0 }));
const ageSexDistributionMap = new Map(ageSexDistribution.map(item => [item.label, item]));

if (isPopulationDataset) {
  for (const row of records) {
    const surveyDate = String(row['調査年月日'] ?? '').trim();
    if (surveyDate) {
      surveyDateSet.add(surveyDate);
    }

    regionPopulationRows.push({
      name: String(row['地域名'] ?? '').trim(),
      total: toNumber(row['総人口']),
      male: toNumber(row['男性']),
      female: toNumber(row['女性']),
      households: toNumber(row['世帯数']),
    });

    for (const column of ageColumns) {
      const target = ageDistributionMap.get(column.label);
      if (!target) {
        continue;
      }

      const value = toNumber(row[column.key]);
      target.total += value;

      const ageSexTarget = ageSexDistributionMap.get(column.label);
      if (!ageSexTarget) {
        continue;
      }

      if (column.sex === 'male') {
        ageSexTarget.male += value;
      } else {
        ageSexTarget.female += value;
      }
      ageSexTarget.total += value;
    }
  }
}

ageDistribution.sort((a, b) => {
  const left = Number((a.label.match(/^(\d+)/) || ['0', '0'])[1]);
  const right = Number((b.label.match(/^(\d+)/) || ['0', '0'])[1]);
  return left - right;
});

ageSexDistribution.sort((a, b) => {
  const left = Number((a.label.match(/^(\d+)/) || ['0', '0'])[1]);
  const right = Number((b.label.match(/^(\d+)/) || ['0', '0'])[1]);
  return left - right;
});

const maxAgePopulation = Math.max(...ageDistribution.map(item => item.total), 0);

const populationSummary = {
  total: 0,
  male: 0,
  female: 0,
  households: 0,
  children: 0,
  working: 0,
  seniors: 0,
  regionCount: 0,
};

if (isPopulationDataset) {
  for (const row of records) {
    populationSummary.total += toNumber(row['総人口']);
    populationSummary.male += toNumber(row['男性']);
    populationSummary.female += toNumber(row['女性']);
    populationSummary.households += toNumber(row['世帯数']);
  }

  for (const item of ageDistribution) {
    const ageStart = Number((item.label.match(/^(\d+)/) || ['0', '0'])[1]);
    if (ageStart <= 14) {
      populationSummary.children += item.total;
    } else if (ageStart <= 64) {
      populationSummary.working += item.total;
    } else {
      populationSummary.seniors += item.total;
    }
  }

  populationSummary.regionCount = regionPopulationRows.filter(row => row.name).length;
}

const populationSurveyDates = Array.from(surveyDateSet);
const populationSurveyDate = populationSurveyDates[0] ?? '';
const hasMultipleSurveyDates = populationSurveyDates.length > 1;

const ageDistributionTotal = ageDistribution.reduce((sum, item) => sum + item.total, 0);
const childrenRate = fmtPercent(populationSummary.children, populationSummary.total);
const workingRate = fmtPercent(populationSummary.working, populationSummary.total);
const seniorsRate = fmtPercent(populationSummary.seniors, populationSummary.total);
const maleShare = fmtPercent(populationSummary.male, populationSummary.total);
const femaleShare = fmtPercent(populationSummary.female, populationSummary.total);
const ageCoverageRate = fmtPercent(ageDistributionTotal, populationSummary.total);
const averageHouseholdSize =
  populationSummary.households > 0 ? populationSummary.total / populationSummary.households : null;
const femalePer100Male =
  populationSummary.male > 0 ? (populationSummary.female / populationSummary.male) * 100 : null;
const dependencyRatio =
  populationSummary.working > 0
    ? ((populationSummary.children + populationSummary.seniors) / populationSummary.working) * 100
    : null;
const agingIndex =
  populationSummary.children > 0 ? (populationSummary.seniors / populationSummary.children) * 100 : null;

const topRegionPopulationRows = [...regionPopulationRows]
  .filter(row => row.name)
  .sort((a, b) => b.total - a.total)
  .slice(0, 8);
const smallestRegionPopulationRows = [...regionPopulationRows]
  .filter(row => row.name)
  .sort((a, b) => a.total - b.total)
  .slice(0, 3);
const maxRegionPopulation = Math.max(...topRegionPopulationRows.map(row => row.total), 0);
const smallestRegionsLabel = smallestRegionPopulationRows
  .map(row => `${row.name} (${row.total.toLocaleString('ja-JP')}人)`)
  .join(' / ');
---

<Layout title={`${dataset.title} | NAMEGATA OPEN DATA`}>
  {hasGeoMap ? (
    <Fragment slot="head">
      <link rel="stylesheet" href={leafletCssUrl} />
    </Fragment>
  ) : null}

  <Nav />

  <main class="section">
    <div class="container dataset-page">
      <a href={homeUrl} class="back-link">← データセット一覧へ戻る</a>

      <header class="page-header card">
        <p class="header-category">{dataset.categoryEn}</p>
        <h1>{dataset.icon} {dataset.title}</h1>
        <p class="header-title-en">{dataset.titleEn}</p>
        <p class="header-description">{dataset.description}</p>

        <div class="quick-stats">
          <div>
            <span class="label">行数</span>
            <strong>{dataset.rowCount?.toLocaleString('ja-JP') ?? '-'} 件</strong>
          </div>
          <div>
            <span class="label">列数</span>
            <strong>{dataset.columnCount ?? '-'} 列</strong>
          </div>
          <div>
            <span class="label">ファイルサイズ</span>
            <strong>{fmtBytes(dataset.fileSizeBytes)}</strong>
          </div>
          <div>
            <span class="label">最終更新（公開）</span>
            <strong>{dataset.updatedAt}</strong>
          </div>
        </div>

        <div class="header-actions">
          <a href={localSnapshotUrl} class="btn-link">このサイトのCSVスナップショット</a>
          <a href={dataset.url} target="_blank" rel="noopener" class="btn-link">市公式CSV</a>
          <a href={dataset.sourcePageUrl} target="_blank" rel="noopener" class="btn-link">市公式詳細ページ</a>
        </div>
      </header>

      {hasGeoMap ? (
        <section class="card map-card">
          <h2>地図（座標表示）</h2>
          <p class="table-note">
            座標付きデータ {geoPoints.length.toLocaleString('ja-JP')} 件のうち、
            市域内 {geoPointsInCity.length.toLocaleString('ja-JP')} 件を地図上に表示しています。
            {excludedOutsideCityCount > 0
              ? ` 市域外と判定された ${excludedOutsideCityCount.toLocaleString('ja-JP')} 件は除外しています。`
              : ''}
            {hiddenGeoPointCount > 0
              ? ` 表示負荷を抑えるため、先頭 ${maxMapPoints} 件を描画しています。`
              : ''}
          </p>

          <div class={`map-and-chart ${hasCategoryChart ? '' : 'single'}`}>
            <div class="map-container">
              <div id={mapElementId} class="map-canvas"></div>
            </div>

            {hasCategoryChart ? (
              <div class="category-card">
                <h3>{categoryHeader} 分布</h3>
                <div class="category-bars">
                  {categoryDistribution.map(item => (
                    <div class="category-row">
                      <span class="category-label">{item.label}</span>
                      <div class="category-track">
                        <div
                          class="category-fill"
                          style={`width: ${(item.count / (maxCategoryCount || 1)) * 100}%`}
                        ></div>
                      </div>
                      <span class="category-count">{item.count}</span>
                    </div>
                  ))}
                </div>
                {hiddenCategoryCount > 0 ? (
                  <p class="category-note">他 {hiddenCategoryCount} 種類は省略しています。</p>
                ) : null}
              </div>
            ) : null}
          </div>
        </section>
      ) : null}

      {hasOnlyOutsideCityGeoPoints ? (
        <section class="card map-card">
          <h2>地図（座標表示）</h2>
          <p class="table-note">
            座標付きデータ {geoPoints.length.toLocaleString('ja-JP')} 件を検出しましたが、
            市域内の座標が0件のため地図表示を省略しています。
          </p>
        </section>
      ) : null}

      {isPopulationDataset && ageDistribution.length > 0 ? (
        <section class="card chart-card">
          <h2>人口動態サマリー（地域合算）</h2>
          <p class="table-note">
            調査日: {populationSurveyDate || '不明'}
            {hasMultipleSurveyDates ? '（複数日付あり）' : ''} / 対象地域:
            {populationSummary.regionCount.toLocaleString('ja-JP')} / 総人口:
            {populationSummary.total.toLocaleString('ja-JP')} 人
          </p>

          <div class="summary-grid">
            <div>
              <span class="label">総人口</span>
              <strong>{populationSummary.total.toLocaleString('ja-JP')} 人</strong>
            </div>
            <div>
              <span class="label">男性</span>
              <strong>{populationSummary.male.toLocaleString('ja-JP')} 人</strong>
            </div>
            <div>
              <span class="label">女性</span>
              <strong>{populationSummary.female.toLocaleString('ja-JP')} 人</strong>
            </div>
            <div>
              <span class="label">世帯数</span>
              <strong>{populationSummary.households.toLocaleString('ja-JP')} 世帯</strong>
            </div>
            <div>
              <span class="label">0-14歳</span>
              <strong>{populationSummary.children.toLocaleString('ja-JP')} 人</strong>
            </div>
            <div>
              <span class="label">15-64歳</span>
              <strong>{populationSummary.working.toLocaleString('ja-JP')} 人</strong>
            </div>
            <div>
              <span class="label">65歳以上</span>
              <strong>{populationSummary.seniors.toLocaleString('ja-JP')} 人</strong>
            </div>
            <div>
              <span class="label">年少人口率</span>
              <strong>{childrenRate}</strong>
            </div>
            <div>
              <span class="label">生産年齢人口率</span>
              <strong>{workingRate}</strong>
            </div>
            <div>
              <span class="label">高齢化率</span>
              <strong>{seniorsRate}</strong>
            </div>
            <div>
              <span class="label">1世帯あたり人口</span>
              <strong>{fmtDecimal(averageHouseholdSize, 2)} 人</strong>
            </div>
          </div>

          <dl class="population-meta">
            <div>
              <dt>男女構成</dt>
              <dd>
                男性 {maleShare} / 女性 {femaleShare}
              </dd>
            </div>
            <div>
              <dt>女性人口比（男性100人あたり）</dt>
              <dd>{fmtDecimal(femalePer100Male, 1)}</dd>
            </div>
            <div>
              <dt>従属人口指数</dt>
              <dd>{fmtDecimal(dependencyRatio, 1)}</dd>
            </div>
            <div>
              <dt>高齢化指数</dt>
              <dd>{fmtDecimal(agingIndex, 1)}</dd>
            </div>
            <div>
              <dt>年齢帯データ充足率</dt>
              <dd>{ageCoverageRate}</dd>
            </div>
          </dl>

          <h3 class="chart-subtitle">年齢階層別人口（男女計）</h3>
          <div class="bar-chart">
            {ageDistribution.map(item => (
              <div class="bar-row">
                <span class="bar-label">{item.label}</span>
                <div class="bar-track">
                  <div
                    class="bar-fill"
                    style={`width: ${(item.total / (maxAgePopulation || 1)) * 100}%`}
                  ></div>
                </div>
                <span class="bar-value">{item.total.toLocaleString('ja-JP')}</span>
              </div>
            ))}
          </div>

          <h3 class="chart-subtitle">年齢階層別内訳（男性 / 女性）</h3>
          <div class="table-wrap compact-table-wrap">
            <table class="population-breakdown-table">
              <thead>
                <tr>
                  <th>年齢階層</th>
                  <th>男性</th>
                  <th>女性</th>
                  <th>計</th>
                  <th>構成比</th>
                </tr>
              </thead>
              <tbody>
                {ageSexDistribution.map(item => (
                  <tr>
                    <td>{item.label}</td>
                    <td>{item.male.toLocaleString('ja-JP')}</td>
                    <td>{item.female.toLocaleString('ja-JP')}</td>
                    <td>{item.total.toLocaleString('ja-JP')}</td>
                    <td>{fmtPercent(item.total, populationSummary.total)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {topRegionPopulationRows.length > 0 ? (
            <>
              <h3 class="chart-subtitle">地域別人口（上位 {topRegionPopulationRows.length}）</h3>
              <div class="bar-chart region-bar-chart">
                {topRegionPopulationRows.map(row => (
                  <div class="bar-row region-bar-row">
                    <span class="bar-label region-label" title={row.name}>{row.name}</span>
                    <div class="bar-track">
                      <div
                        class="bar-fill"
                        style={`width: ${(row.total / (maxRegionPopulation || 1)) * 100}%`}
                      ></div>
                    </div>
                    <span class="bar-value">{row.total.toLocaleString('ja-JP')} 人</span>
                  </div>
                ))}
              </div>
              {smallestRegionsLabel ? (
                <p class="table-note">人口最少地域: {smallestRegionsLabel}</p>
              ) : null}
            </>
          ) : null}
        </section>
      ) : null}

      {dataset.status !== 'available' ? (
        <section class="card warning-card">
          <h2>データ取得エラー</h2>
          <p>このデータセットは直近更新で取得に失敗しました。</p>
          <code>{dataset.error ?? '不明なエラー'}</code>
        </section>
      ) : (
        <section class="card">
          <h2>データプレビュー（先頭 {previewRows.length} 件）</h2>
          <p class="table-note">
            市民向けにデータ内容を確認しやすくするため、先頭20件を表示しています。
            全件はCSVをダウンロードして確認できます。
          </p>

          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  {headerLabels.map(header => <th>{header}</th>)}
                </tr>
              </thead>
              <tbody>
                {previewRows.map(row => (
                  <tr>
                    {tableKeys.map(key => <td>{row[key]}</td>)}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </section>
      )}

      <details class="card evidence-card" open>
        <summary>エビデンス情報</summary>
        <dl>
          <dt>取得元URL</dt>
          <dd><a href={evidenceSourceUrl} target="_blank" rel="noopener">{evidenceSourceUrl}</a></dd>

          <dt>取得日時</dt>
          <dd>{fmtDateTime(evidenceFetchedAt)}</dd>

          <dt>SHA-256</dt>
          <dd class="mono">{evidenceSha}</dd>

          <dt>ライセンス</dt>
          <dd>{evidenceLicense}</dd>

          <dt>詳細ページ</dt>
          <dd>
            <a href={evidencePageUrl} target="_blank" rel="noopener">{evidencePageUrl}</a>
          </dd>

          <dt>変換処理</dt>
          <dd>{transformationText}</dd>

          <dt>地図除外座標</dt>
          <dd>
            {excludedOutsideCityCount === 0 ? (
              <>
                <p class="evidence-note">
                  判定基準: 緯度 {NAMEGATA_CITY_BOUNDS.minLat} 〜 {NAMEGATA_CITY_BOUNDS.maxLat} /
                  経度 {NAMEGATA_CITY_BOUNDS.minLon} 〜 {NAMEGATA_CITY_BOUNDS.maxLon}
                </p>
                なし
              </>
            ) : (
              <>
                <p class="evidence-note">
                  判定基準: 緯度 {NAMEGATA_CITY_BOUNDS.minLat} 〜 {NAMEGATA_CITY_BOUNDS.maxLat} /
                  経度 {NAMEGATA_CITY_BOUNDS.minLon} 〜 {NAMEGATA_CITY_BOUNDS.maxLon}
                </p>
                <p class="evidence-note">
                  市域外と判定した {excludedOutsideCityCount.toLocaleString('ja-JP')} 件を
                  地図表示から除外しています（先頭 {excludedPointPreview.length.toLocaleString('ja-JP')} 件を表示）。
                </p>
                <div class="excluded-points-wrap">
                  <table class="excluded-points-table">
                    <thead>
                      <tr>
                        <th>名称</th>
                        <th>緯度</th>
                        <th>経度</th>
                        <th>補足</th>
                      </tr>
                    </thead>
                    <tbody>
                      {excludedPointPreview.map(point => (
                        <tr>
                          <td>{point.label}</td>
                          <td>{point.lat.toFixed(6)}</td>
                          <td>{point.lon.toFixed(6)}</td>
                          <td>{point.sublabel || '-'}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {hiddenExcludedOutsideCityCount > 0 ? (
                  <p class="evidence-note">
                    他 {hiddenExcludedOutsideCityCount.toLocaleString('ja-JP')} 件は省略しています。
                  </p>
                ) : null}
              </>
            )}
          </dd>
        </dl>
      </details>
    </div>
  </main>

  {hasGeoMap ? (
    <>
      <script is:inline src={leafletJsUrl}></script>
      <script is:inline define:vars={{ mapElementId, mapPoints }}>
        const showMapError = message => {
          const element = document.getElementById(mapElementId);
          if (!element) {
            return;
          }

          element.innerHTML = `<p class="map-error-text">${message}</p>`;
        };

        const sanitizeHtml = value =>
          String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        const initializeMap = () => {
          const element = document.getElementById(mapElementId);
          if (!element || !window.L) {
            return false;
          }

          try {
            const map = window.L.map(element, {
              scrollWheelZoom: false,
              preferCanvas: true,
            });

            window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '&copy; OpenStreetMap contributors',
            }).addTo(map);

            const bounds = [];
            for (const point of mapPoints) {
              const marker = window.L.circleMarker([point.lat, point.lon], {
                radius: 5,
                weight: 1,
                color: '#0f172a',
                fillColor: '#22c55e',
                fillOpacity: 0.8,
              });

              const label = sanitizeHtml(point.label || '');
              const sublabel = sanitizeHtml(point.sublabel || '');
              marker.bindPopup(sublabel ? `<strong>${label}</strong><br>${sublabel}` : label);
              marker.addTo(map);
              bounds.push([point.lat, point.lon]);
            }

            if (bounds.length === 1) {
              map.setView(bounds[0], 14);
            } else if (bounds.length > 1) {
              map.fitBounds(bounds, { padding: [24, 24] });
            }
          } catch (error) {
            showMapError('地図の描画に失敗しました。再読み込みしてください。');
            return true;
          }

          return true;
        };

        if (!initializeMap()) {
          let retries = 0;
          const timer = setInterval(() => {
            retries += 1;
            if (initializeMap() || retries > 20) {
              if (retries > 20) {
                showMapError('地図ライブラリの読み込みに失敗しました。');
              }
              clearInterval(timer);
            }
          }, 150);
        }
      </script>
    </>
  ) : null}

  <Footer />
</Layout>

<style>
  .dataset-page {
    display: flex;
    flex-direction: column;
    gap: 1.1rem;
  }

  .back-link {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--text-secondary);
  }

  .page-header h1 {
    font-size: clamp(1.3rem, 3vw, 1.8rem);
    margin-top: 0.35rem;
  }

  .header-category {
    font-family: var(--font-mono);
    font-size: 0.68rem;
    letter-spacing: 0.12em;
    color: var(--accent-green);
  }

  .header-title-en {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
  }

  .header-description {
    margin-top: 0.5rem;
    color: var(--text-secondary);
    font-size: 0.92rem;
  }

  .quick-stats {
    margin-top: 1rem;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 0.65rem;
  }

  .quick-stats div {
    background: var(--bg-base);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.55rem 0.7rem;
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
  }

  .quick-stats .label {
    font-family: var(--font-mono);
    font-size: 0.62rem;
    letter-spacing: 0.08em;
    color: var(--text-dim);
  }

  .quick-stats strong {
    font-family: var(--font-mono);
    font-size: 0.82rem;
    color: var(--text-primary);
  }

  .header-actions {
    margin-top: 0.85rem;
    display: flex;
    gap: 0.55rem;
    flex-wrap: wrap;
  }

  .btn-link {
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.28rem 0.6rem;
    font-family: var(--font-mono);
    font-size: 0.68rem;
    color: var(--text-secondary);
  }

  .btn-link:hover {
    border-color: var(--border-hover);
    color: var(--text-primary);
  }

  .warning-card h2 {
    font-size: 1rem;
    margin-bottom: 0.55rem;
  }

  .warning-card p {
    color: var(--accent-orange);
    margin-bottom: 0.5rem;
  }

  .table-note {
    color: var(--text-secondary);
    font-size: 0.84rem;
    margin-top: 0.45rem;
  }

  .map-card h2 {
    font-size: 1rem;
  }

  .map-and-chart {
    margin-top: 0.85rem;
    display: grid;
    grid-template-columns: minmax(0, 1.7fr) minmax(0, 1fr);
    gap: 0.9rem;
    align-items: start;
  }

  .map-and-chart.single {
    grid-template-columns: 1fr;
  }

  .map-container {
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
    background: var(--bg-base);
  }

  .map-canvas {
    width: 100%;
    height: 420px;
  }

  .map-canvas :global(.map-error-text) {
    margin: 0;
    height: 100%;
    display: grid;
    place-items: center;
    text-align: center;
    padding: 1rem;
    color: var(--text-secondary);
    font-size: 0.82rem;
  }

  .category-card {
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 0.65rem;
    background: var(--bg-base);
  }

  .category-card h3 {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 0.6rem;
    font-family: var(--font-mono);
  }

  .category-bars {
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }

  .category-row {
    display: grid;
    grid-template-columns: minmax(70px, 1fr) minmax(0, 1.2fr) 40px;
    gap: 0.45rem;
    align-items: center;
  }

  .category-label {
    color: var(--text-secondary);
    font-size: 0.68rem;
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .category-track {
    height: 10px;
    border: 1px solid rgba(59, 130, 246, 0.24);
    background: rgba(59, 130, 246, 0.1);
    border-radius: 999px;
    overflow: hidden;
  }

  .category-fill {
    height: 100%;
    min-width: 2px;
    background: linear-gradient(90deg, var(--accent-blue), var(--accent-orange));
  }

  .category-count {
    font-family: var(--font-mono);
    font-size: 0.67rem;
    color: var(--text-secondary);
    text-align: right;
  }

  .category-note {
    margin-top: 0.6rem;
    color: var(--text-dim);
    font-size: 0.68rem;
  }

  .chart-card h2 {
    font-size: 1rem;
  }

  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
    gap: 0.6rem;
    margin-top: 0.75rem;
  }

  .summary-grid div {
    background: var(--bg-base);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.55rem 0.65rem;
    display: flex;
    flex-direction: column;
    gap: 0.12rem;
  }

  .summary-grid .label {
    font-family: var(--font-mono);
    font-size: 0.62rem;
    letter-spacing: 0.08em;
    color: var(--text-dim);
  }

  .summary-grid strong {
    font-family: var(--font-mono);
    font-size: 0.82rem;
    color: var(--text-primary);
  }

  .population-meta {
    margin-top: 0.8rem;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
    gap: 0.55rem;
  }

  .population-meta div {
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--bg-base);
    padding: 0.5rem 0.6rem;
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
  }

  .population-meta dt {
    font-family: var(--font-mono);
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.04em;
  }

  .population-meta dd {
    margin: 0;
    font-family: var(--font-mono);
    font-size: 0.76rem;
    color: var(--text-primary);
  }

  .chart-subtitle {
    margin-top: 1rem;
    font-family: var(--font-mono);
    font-size: 0.78rem;
    color: var(--text-secondary);
    letter-spacing: 0.05em;
  }

  .bar-chart {
    margin-top: 0.9rem;
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }

  .bar-row {
    display: grid;
    grid-template-columns: 88px 1fr 78px;
    gap: 0.6rem;
    align-items: center;
  }

  .bar-label {
    font-family: var(--font-mono);
    font-size: 0.68rem;
    color: var(--text-secondary);
  }

  .bar-track {
    height: 11px;
    border-radius: 999px;
    overflow: hidden;
    background: rgba(59, 130, 246, 0.12);
    border: 1px solid rgba(59, 130, 246, 0.22);
  }

  .bar-fill {
    height: 100%;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--accent-blue), var(--accent-green));
    min-width: 2px;
  }

  .bar-value {
    font-family: var(--font-mono);
    font-size: 0.68rem;
    color: var(--text-secondary);
    text-align: right;
  }

  .compact-table-wrap {
    margin-top: 0.75rem;
  }

  .population-breakdown-table {
    min-width: 620px;
    font-size: 0.7rem;
  }

  .population-breakdown-table td:nth-child(2),
  .population-breakdown-table td:nth-child(3),
  .population-breakdown-table td:nth-child(4),
  .population-breakdown-table td:nth-child(5) {
    font-family: var(--font-mono);
    text-align: right;
    white-space: nowrap;
  }

  .region-bar-row {
    grid-template-columns: minmax(92px, 1fr) 1fr 86px;
  }

  .region-label {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .table-wrap {
    margin-top: 0.85rem;
    overflow: auto;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--bg-base);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
    min-width: 780px;
  }

  th,
  td {
    border-bottom: 1px solid var(--border);
    padding: 0.45rem 0.55rem;
    text-align: left;
    vertical-align: top;
  }

  th {
    font-family: var(--font-mono);
    font-size: 0.66rem;
    background: var(--bg-card);
    position: sticky;
    top: 0;
  }

  td {
    color: var(--text-secondary);
    line-height: 1.45;
    word-break: break-word;
  }

  .evidence-card summary {
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: 0.78rem;
    color: var(--text-secondary);
  }

  .evidence-card dl {
    margin-top: 0.75rem;
    display: grid;
    grid-template-columns: 120px 1fr;
    gap: 0.45rem 0.8rem;
    font-size: 0.74rem;
  }

  .evidence-card dt {
    font-family: var(--font-mono);
    color: var(--text-dim);
  }

  .evidence-card dd {
    color: var(--text-secondary);
    word-break: break-all;
  }

  .evidence-note {
    margin: 0;
    font-size: 0.7rem;
    line-height: 1.4;
    color: var(--text-secondary);
  }

  .excluded-points-wrap {
    margin-top: 0.45rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: auto;
    background: var(--bg-base);
  }

  .excluded-points-table {
    min-width: 560px;
    font-size: 0.68rem;
  }

  .excluded-points-table th,
  .excluded-points-table td {
    padding: 0.35rem 0.45rem;
  }

  .excluded-points-table td:nth-child(2),
  .excluded-points-table td:nth-child(3) {
    font-family: var(--font-mono);
    white-space: nowrap;
  }

  @media (max-width: 640px) {
    .map-and-chart {
      grid-template-columns: 1fr;
    }

    .map-canvas {
      height: 320px;
    }

    .bar-row {
      grid-template-columns: 70px 1fr 62px;
      gap: 0.45rem;
    }

    .region-bar-row {
      grid-template-columns: minmax(70px, 1fr) 1fr 74px;
    }

    .population-meta {
      grid-template-columns: 1fr;
    }

    .evidence-card dl {
      grid-template-columns: 1fr;
    }

    .evidence-card dt {
      margin-top: 0.45rem;
    }

    table {
      min-width: 640px;
    }

    .excluded-points-table {
      min-width: 520px;
    }

    .population-breakdown-table {
      min-width: 520px;
    }
  }
</style>
